# Story 1.6: Implementar Keep-Alive Autom√°tico de Sess√µes

## Status
**Draft**

## Story

**Como** operador,
**Eu quero** que minha sess√£o permane√ßa ativa durante todo o turno de 8 horas,
**Para que** eu n√£o perca dados por desconex√£o autom√°tica e continue registrando apontamentos contempor√¢neos.

## Acceptance Criteria

1. Supabase Client inicializado com `autoRefreshToken: true` em `lib/supabase.ts`
2. Timer setInterval executando `supabase.auth.getSession()` a cada 50 minutos (antes de token expirar em 1h)
3. Heartbeat query leve (`SELECT 1`) executado a cada 5 minutos para manter conex√£o PostgreSQL ativa
4. Contador de tempo de sess√£o exibido no header: "Sess√£o ativa: Xh Ymin"
5. Auto-reconnect implementado: se token refresh falhar, tentar 3x com exponential backoff (1s, 2s, 4s)
6. Log de atividade de keep-alive em console (dev mode) ou Supabase Dashboard (prod)
7. Toast de alerta se sess√£o falhar ap√≥s 3 tentativas: "Sess√£o expirou. Fa√ßa login novamente."
8. Testes manuais: sess√£o permanece ativa por 8h+ sem interrup√ß√£o

## Tasks / Subtasks

- [ ] **Task 1: Configurar autoRefreshToken** (AC: 1)
  - [ ] Abrir `apps/web/src/lib/supabase.ts`
  - [ ] Adicionar `autoRefreshToken: true` no createClient()
  - [ ] Adicionar `persistSession: true`

- [ ] **Task 2: Criar KeepAliveService** (AC: 2, 3)
  - [ ] Criar arquivo `apps/web/src/services/keepalive.service.ts`
  - [ ] Implementar classe KeepAliveService
  - [ ] Timer token refresh: 50 minutos
  - [ ] Timer heartbeat: 5 minutos

- [ ] **Task 3: Implementar Token Refresh** (AC: 2)
  - [ ] setInterval(50 * 60 * 1000) // 50 min
  - [ ] Executar `supabase.auth.getSession()`
  - [ ] Logar resultado: "Token refreshed successfully"

- [ ] **Task 4: Implementar Heartbeat Query** (AC: 3)
  - [ ] setInterval(5 * 60 * 1000) // 5 min
  - [ ] Query leve: `SELECT 1` via Supabase
  - [ ] Logar: "Heartbeat OK"

- [ ] **Task 5: Implementar Auto-Reconnect** (AC: 5)
  - [ ] Fun√ß√£o `retryRefresh(attempts = 3)`
  - [ ] Exponential backoff: 1s, 2s, 4s
  - [ ] Se todas tentativas falharem: emitir evento "session-expired"

- [ ] **Task 6: Criar Session Timer** (AC: 4)
  - [ ] Estado: `sessionStartTime` (timestamp login)
  - [ ] Calcular diferen√ßa: now - sessionStartTime
  - [ ] Formatar: "Xh Ymin"
  - [ ] Atualizar a cada 1 minuto

- [ ] **Task 7: Criar Session Timer Component** (AC: 4)
  - [ ] Componente `<SessionTimer />` no header
  - [ ] Exibir "Sess√£o ativa: Xh Ymin"
  - [ ] Atualizar em tempo real

- [ ] **Task 8: Implementar Toast de Expira√ß√£o** (AC: 7)
  - [ ] Listener no evento "session-expired"
  - [ ] Exibir toast erro: "Sess√£o expirou. Fa√ßa login novamente."
  - [ ] Redirecionar para /login ap√≥s 5 segundos

- [ ] **Task 9: Configurar Logging** (AC: 6)
  - [ ] Dev mode: console.log()
  - [ ] Prod mode: enviar para Supabase (opcional)
  - [ ] Log: timestamp, evento (refresh/heartbeat)

- [ ] **Task 10: Integrar com App** (AC: 8)
  - [ ] Inicializar KeepAliveService no App.tsx (useEffect)
  - [ ] Cleanup ao desmontar: stop timers
  - [ ] Testar: deixar aberto 8h+ (ou simular)

- [ ] **Task 11: Teste de Longa Dura√ß√£o** (AC: 8)
  - [ ] Deixar navegador aberto 8h+
  - [ ] Monitorar console: refreshes a cada 50min
  - [ ] Monitorar console: heartbeats a cada 5min
  - [ ] Verificar que n√£o desconecta

- [ ] **Task 12: Teste de Falha de Rede**
  - [ ] Simular falha: DevTools ‚Üí Network ‚Üí Offline (30s)
  - [ ] Verificar retry exponential backoff
  - [ ] Voltar online ‚Üí deve reconectar automaticamente

## Dev Notes

### Previous Story Insights
**Story Anterior:** 1.5 (Offline-First)
- SyncService j√° tem l√≥gica de retry
- Agora vamos garantir que sess√£o JWT n√£o expire
- Combina√ß√£o: offline-first + keep-alive = turno 8h sem perdas

### Keep-Alive Architecture

**Problema:**
- Supabase JWT expira em 1h por padr√£o
- Operador trabalha 8h+ por turno
- Se sess√£o expirar ‚Üí apontamentos podem falhar

**Solu√ß√£o:**
1. **Auto-refresh token:** Supabase faz automaticamente
2. **Manual refresh:** For√ßar a cada 50min (antes de expirar)
3. **Heartbeat:** Query leve mant√©m conex√£o PostgreSQL ativa
4. **Retry:** Se falhar, tentar novamente antes de desistir

### Supabase Client Configuration

```typescript
// apps/web/src/lib/supabase.ts (atualizado)
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY

export const supabase = createClient(supabaseUrl, supabaseAnonKey, {
  auth: {
    autoRefreshToken: true,        // ‚Üê AC#1
    persistSession: true,
    detectSessionInUrl: true
  }
})
```

### KeepAlive Service

```typescript
// apps/web/src/services/keepalive.service.ts
import { supabase } from '@/lib/supabase'

export class KeepAliveService {
  private refreshIntervalId: number | null = null
  private heartbeatIntervalId: number | null = null

  start() {
    console.log('üöÄ KeepAlive Service started')

    // Token Refresh: 50 minutos
    this.refreshIntervalId = window.setInterval(
      () => this.refreshToken(),
      50 * 60 * 1000
    )

    // Heartbeat: 5 minutos
    this.heartbeatIntervalId = window.setInterval(
      () => this.heartbeat(),
      5 * 60 * 1000
    )

    // Executar imediatamente
    this.refreshToken()
    this.heartbeat()
  }

  stop() {
    if (this.refreshIntervalId) {
      clearInterval(this.refreshIntervalId)
    }
    if (this.heartbeatIntervalId) {
      clearInterval(this.heartbeatIntervalId)
    }
    console.log('üõë KeepAlive Service stopped')
  }

  async refreshToken() {
    try {
      const { data, error } = await supabase.auth.getSession()

      if (error) throw error

      console.log('‚úÖ Token refreshed:', new Date().toISOString())
      return true
    } catch (error) {
      console.error('‚ùå Token refresh failed:', error)
      return this.retryRefresh()
    }
  }

  async heartbeat() {
    try {
      const { error } = await supabase.rpc('heartbeat')

      if (error) {
        // Fun√ß√£o heartbeat pode n√£o existir, usar query simples
        await supabase.from('setores').select('count').limit(1)
      }

      console.log('üíì Heartbeat OK:', new Date().toISOString())
    } catch (error) {
      console.error('‚ùå Heartbeat failed:', error)
    }
  }

  async retryRefresh(attempts = 3) {
    for (let i = 0; i < attempts; i++) {
      const delay = Math.pow(2, i) * 1000 // 1s, 2s, 4s

      console.log(`üîÑ Retry ${i + 1}/${attempts} in ${delay}ms...`)
      await new Promise(resolve => setTimeout(resolve, delay))

      const success = await this.refreshToken()
      if (success) return true
    }

    // Todas tentativas falharam
    this.emitSessionExpired()
    return false
  }

  emitSessionExpired() {
    const event = new CustomEvent('session-expired')
    window.dispatchEvent(event)
  }
}

export const keepAliveService = new KeepAliveService()
```

### Session Timer Component

```typescript
// apps/web/src/components/SessionTimer.tsx
import { useState, useEffect } from 'react'
import { supabase } from '@/lib/supabase'

export function SessionTimer() {
  const [sessionStart, setSessionStart] = useState<Date | null>(null)
  const [elapsed, setElapsed] = useState('')

  useEffect(() => {
    // Obter timestamp do login
    supabase.auth.getSession().then(({ data }) => {
      if (data.session) {
        // Sess√£o existe, usar timestamp atual como aproxima√ß√£o
        // (idealmente salvar no localStorage ao fazer login)
        const start = localStorage.getItem('session_start')
        setSessionStart(start ? new Date(start) : new Date())
      }
    })

    // Atualizar a cada 1 minuto
    const interval = setInterval(() => {
      if (sessionStart) {
        const now = new Date()
        const diff = now.getTime() - sessionStart.getTime()

        const hours = Math.floor(diff / (1000 * 60 * 60))
        const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60))

        setElapsed(`${hours}h ${minutes}min`)
      }
    }, 60000) // 1 minuto

    return () => clearInterval(interval)
  }, [sessionStart])

  if (!elapsed) return null

  return (
    <div className="text-sm text-gray-600">
      Sess√£o ativa: {elapsed}
    </div>
  )
}
```

### App Integration

```typescript
// apps/web/src/App.tsx
import { useEffect } from 'react'
import { keepAliveService } from '@/services/keepalive.service'
import { useNavigate } from 'react-router-dom'
import { toast } from '@/components/ui/use-toast'

export function App() {
  const navigate = useNavigate()

  useEffect(() => {
    // Iniciar KeepAlive
    keepAliveService.start()

    // Listener para sess√£o expirada
    const handleSessionExpired = () => {
      toast({
        title: 'Sess√£o expirou',
        description: 'Fa√ßa login novamente.',
        variant: 'destructive'
      })

      setTimeout(() => {
        navigate('/login')
      }, 5000)
    }

    window.addEventListener('session-expired', handleSessionExpired)

    // Cleanup
    return () => {
      keepAliveService.stop()
      window.removeEventListener('session-expired', handleSessionExpired)
    }
  }, [navigate])

  return (
    // ... resto do app
  )
}
```

### NFR Compliance

**[Fonte: Epic 8 - NFR4]**
- ‚úÖ **NFR4:** Sess√µes longas (8h+) sem desconex√£o
- ‚úÖ Auto-refresh token antes de expirar
- ‚úÖ Retry com exponential backoff
- ‚úÖ Heartbeat mant√©m conex√£o ativa

### Testing

**Teste 1: Token Refresh (50min)**
```javascript
// Simular - n√£o esperar 50min
// Chamar manualmente:
keepAliveService.refreshToken()
// Verificar console: "‚úÖ Token refreshed"
```

**Teste 2: Heartbeat (5min)**
```javascript
// Simular
keepAliveService.heartbeat()
// Verificar console: "üíì Heartbeat OK"
```

**Teste 3: Retry Exponential Backoff**
```javascript
// Desconectar internet
// Chamar:
keepAliveService.retryRefresh(3)
// Verificar console:
// "üîÑ Retry 1/3 in 1000ms..."
// "üîÑ Retry 2/3 in 2000ms..."
// "üîÑ Retry 3/3 in 4000ms..."
```

**Teste 4: Longa Dura√ß√£o (8h)**
- Deixar navegador aberto overnight
- Verificar logs: refreshes a cada 50min
- Tentar criar apontamento ap√≥s 8h ‚Üí deve funcionar

### Troubleshooting

**Sess√£o expira mesmo com keep-alive:**
- Verificar que `autoRefreshToken: true`
- Verificar console: refreshes acontecendo?
- Verificar Supabase Dashboard ‚Üí Auth ‚Üí Users ‚Üí Last Sign In

**Heartbeat falhando:**
- Verificar RLS: query pode estar bloqueada
- Criar fun√ß√£o SQL `heartbeat()` que retorna TRUE
- Ou usar query simples: `SELECT 1`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-26 | 1.0 | Hist√≥ria criada | Sarah (Product Owner) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo Dev Agent_

### Debug Log References
_A ser preenchido pelo Dev Agent_

### Completion Notes
_A ser preenchido pelo Dev Agent_

### File List
_A ser preenchido pelo Dev Agent_

---

## QA Results
_A ser preenchido pelo QA Agent_

# Story 1.5: Implementar Offline-First Buffer (IndexedDB)

## Status
**Draft**

## Story

**Como** operador,
**Eu quero** que o sistema continue funcionando quando internet cair,
**Para que** eu não perca dados de apontamentos contemporâneos durante meu turno.

## Acceptance Criteria

1. Biblioteca Dexie.js instalada e configurada em `apps/web/src/lib/db.ts`
2. Schema IndexedDB: tabela `pending_apontamentos` com campos: id, linha_id, tipo_evento, codigo_parada, timestamp_ocorrencia, quantidade_afetada, observacoes, created_at_local
3. Função `saveToPendingQueue(apontamento)` salvando no IndexedDB quando offline
4. Service `SyncService` tentando sincronizar pending_apontamentos com Supabase a cada 10 segundos
5. Event listeners `window.addEventListener('online')` e `offline` atualizando estado de conexão
6. Apontamentos sincronizados são removidos do IndexedDB automaticamente
7. UI exibindo badge de status: "Online" (verde), "Offline - X pendentes" (amarelo), "Sincronizando..." (azul)
8. Limite máximo de 10.000 registros no IndexedDB (FIFO - remove mais antigos se atingir limite)

## Tasks / Subtasks

- [ ] **Task 1: Instalar Dexie.js** (AC: 1)
  - [ ] `cd apps/web && npm install dexie`
  - [ ] Verificar compatibilidade com React 19

- [ ] **Task 2: Criar Database IndexedDB** (AC: 1, 2)
  - [ ] Criar arquivo `apps/web/src/lib/db.ts`
  - [ ] Definir schema Dexie: `pending_apontamentos` table
  - [ ] Inicializar database: `new Dexie('sysoee_offline')`

- [ ] **Task 3: Implementar saveToPendingQueue** (AC: 3)
  - [ ] Função recebe objeto apontamento
  - [ ] Gera UUID local (crypto.randomUUID())
  - [ ] Adiciona created_at_local (timestamp)
  - [ ] INSERT no IndexedDB: `db.pending_apontamentos.add(...)`

- [ ] **Task 4: Criar SyncService** (AC: 4, 6)
  - [ ] Criar arquivo `apps/web/src/services/sync.service.ts`
  - [ ] setInterval(10 segundos) para tentar sync
  - [ ] Para cada pending: INSERT no Supabase
  - [ ] Se sucesso: DELETE do IndexedDB
  - [ ] Se erro: manter no IndexedDB (retry próximo ciclo)

- [ ] **Task 5: Implementar Detecção de Conectividade** (AC: 5)
  - [ ] window.addEventListener('online', handleOnline)
  - [ ] window.addEventListener('offline', handleOffline)
  - [ ] Estado global: `useConnectionStore` (Zustand)
  - [ ] Atualizar badge quando mudar

- [ ] **Task 6: Criar Badge de Status** (AC: 7)
  - [ ] Componente `<ConnectionBadge />` no header
  - [ ] Estados: Online (🟢), Offline (🟡), Sincronizando (🔵)
  - [ ] Mostrar count de pendentes quando offline
  - [ ] Atualizar em tempo real

- [ ] **Task 7: Implementar Limite FIFO** (AC: 8)
  - [ ] Antes de adicionar: verificar count
  - [ ] Se count >= 10.000: deletar mais antigo (orderBy created_at_local)
  - [ ] Logar warning se atingir limite

- [ ] **Task 8: Integrar com Formulário de Apontamento**
  - [ ] Modificar ApontamentoService (Story 3.2)
  - [ ] Detectar se online/offline
  - [ ] Se online: INSERT Supabase
  - [ ] Se offline: saveToPendingQueue()

- [ ] **Task 9: Testar Offline Flow**
  - [ ] DevTools → Network → Offline
  - [ ] Criar apontamento → deve salvar IndexedDB
  - [ ] Badge deve mostrar "Offline - 1 pendente"
  - [ ] Voltar online → deve sincronizar automaticamente
  - [ ] Badge deve voltar "Online"

- [ ] **Task 10: Testar Persistência**
  - [ ] Criar apontamento offline
  - [ ] Fechar navegador
  - [ ] Reabrir → dados devem estar no IndexedDB
  - [ ] Voltar online → deve sincronizar

## Dev Notes

### Previous Story Insights
**Story Anterior:** 1.4 (Schema Banco)
- Tabela `apontamentos` já existe no Supabase
- Agora vamos criar buffer local (IndexedDB) para offline-first
- Sincronizar com Supabase quando voltar online

### IndexedDB with Dexie.js

**Why Dexie.js?**
- Wrapper amigável sobre IndexedDB nativo
- Promises em vez de callbacks
- TypeScript support nativo
- Reactive hooks para React

**Database Configuration:**
```typescript
// apps/web/src/lib/db.ts
import Dexie, { Table } from 'dexie'

export interface PendingApontamento {
  id?: string // UUID local
  linha_id: string
  user_id: string
  tipo_evento: 'parada' | 'perda_qualidade' | 'troca_turno'
  codigo_parada: string
  timestamp_ocorrencia: string // ISO string
  duracao_minutos?: number
  quantidade_afetada?: number
  observacoes?: string
  created_at_local: string // quando foi salvo localmente
}

export class SysOEEDatabase extends Dexie {
  pending_apontamentos!: Table<PendingApontamento, string>

  constructor() {
    super('sysoee_offline')
    this.version(1).stores({
      pending_apontamentos: 'id, linha_id, created_at_local'
    })
  }
}

export const db = new SysOEEDatabase()
```

### Sync Service

```typescript
// apps/web/src/services/sync.service.ts
import { db } from '@/lib/db'
import { supabase } from '@/lib/supabase'

export class SyncService {
  private intervalId: number | null = null

  start() {
    // Sincronizar a cada 10 segundos
    this.intervalId = window.setInterval(() => {
      this.syncPending()
    }, 10000)

    // Sincronizar imediatamente ao iniciar
    this.syncPending()
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }
  }

  async syncPending() {
    if (!navigator.onLine) return

    const pending = await db.pending_apontamentos.toArray()

    for (const item of pending) {
      try {
        // Tentar inserir no Supabase
        const { error } = await supabase
          .from('apontamentos')
          .insert({
            linha_id: item.linha_id,
            user_id: item.user_id,
            tipo_evento: item.tipo_evento,
            codigo_parada: item.codigo_parada,
            timestamp_ocorrencia: item.timestamp_ocorrencia,
            duracao_minutos: item.duracao_minutos,
            quantidade_afetada: item.quantidade_afetada,
            observacoes: item.observacoes
          })

        if (!error && item.id) {
          // Sucesso: remover do IndexedDB
          await db.pending_apontamentos.delete(item.id)
          console.log('✅ Apontamento sincronizado:', item.id)
        }
      } catch (error) {
        console.error('❌ Erro ao sincronizar:', error)
        // Não remove do IndexedDB - tentará novamente
      }
    }
  }

  async getPendingCount() {
    return await db.pending_apontamentos.count()
  }
}

export const syncService = new SyncService()
```

### Connection State Management

```typescript
// apps/web/src/stores/connection.store.ts
import { create } from 'zustand'

interface ConnectionState {
  isOnline: boolean
  isSyncing: boolean
  pendingCount: number
  setOnline: (online: boolean) => void
  setSyncing: (syncing: boolean) => void
  setPendingCount: (count: number) => void
}

export const useConnectionStore = create<ConnectionState>((set) => ({
  isOnline: navigator.onLine,
  isSyncing: false,
  pendingCount: 0,
  setOnline: (online) => set({ isOnline: online }),
  setSyncing: (syncing) => set({ isSyncing: syncing }),
  setPendingCount: (count) => set({ pendingCount: count })
}))

// Inicializar listeners
window.addEventListener('online', () => {
  useConnectionStore.getState().setOnline(true)
  syncService.syncPending() // Sincronizar imediatamente
})

window.addEventListener('offline', () => {
  useConnectionStore.getState().setOnline(false)
})
```

### Connection Badge Component

```typescript
// apps/web/src/components/ConnectionBadge.tsx
import { useConnectionStore } from '@/stores/connection.store'

export function ConnectionBadge() {
  const { isOnline, isSyncing, pendingCount } = useConnectionStore()

  if (isOnline && pendingCount === 0) {
    return <div className="badge badge-success">🟢 Online</div>
  }

  if (isSyncing) {
    return <div className="badge badge-info">🔵 Sincronizando...</div>
  }

  if (!isOnline) {
    return (
      <div className="badge badge-warning">
        🟡 Offline - {pendingCount} pendentes
      </div>
    )
  }

  return null
}
```

### FIFO Limit Implementation

```typescript
async function saveToPendingQueue(apontamento: PendingApontamento) {
  // Verificar limite
  const count = await db.pending_apontamentos.count()

  if (count >= 10000) {
    // Remover mais antigo (FIFO)
    const oldest = await db.pending_apontamentos
      .orderBy('created_at_local')
      .first()

    if (oldest?.id) {
      await db.pending_apontamentos.delete(oldest.id)
      console.warn('⚠️ Limite IndexedDB atingido. Removido registro mais antigo.')
    }
  }

  // Adicionar novo
  const id = crypto.randomUUID()
  await db.pending_apontamentos.add({
    ...apontamento,
    id,
    created_at_local: new Date().toISOString()
  })

  // Atualizar count no store
  useConnectionStore.getState().setPendingCount(count + 1)

  return id
}
```

### NFR Compliance

**[Fonte: Epic 8 - NFR15]**
- ✅ **NFR15:** Contemporaneidade > 98%
- ✅ Offline-first garante zero perda de dados
- ✅ Sincronização automática quando reconectar
- ✅ FIFO prevent overflow (limite 10.000)

### Testing Scenarios

**Teste 1: Criar Offline**
1. DevTools → Network → Offline
2. Criar apontamento
3. Verificar IndexedDB (DevTools → Application → IndexedDB → sysoee_offline)
4. Deve ter 1 registro

**Teste 2: Sincronizar**
1. Criar apontamento offline
2. DevTools → Network → Online
3. Aguardar 10 segundos (ou forçar sync)
4. Verificar IndexedDB → deve estar vazio
5. Verificar Supabase → deve ter registro

**Teste 3: Persistência**
1. Criar 5 apontamentos offline
2. Fechar aba do navegador
3. Reabrir
4. IndexedDB deve ter 5 registros
5. Voltar online → sincronizar todos

**Teste 4: Limite FIFO**
1. Criar script para adicionar 10.001 registros
2. Verificar que mantém apenas 10.000
3. Verificar que removeu o mais antigo

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-26 | 1.0 | História criada | Sarah (Product Owner) |

---

## Dev Agent Record

### Agent Model Used
_A ser preenchido pelo Dev Agent_

### Debug Log References
_A ser preenchido pelo Dev Agent_

### Completion Notes
_A ser preenchido pelo Dev Agent_

### File List
_A ser preenchido pelo Dev Agent_

---

## QA Results
_A ser preenchido pelo QA Agent_

# Epic 3: Apontamentos Contempor√¢neos & Integra√ß√£o IoT

[‚Üê Voltar ao √çndice](./index.md)

---


## Epic 3: Apontamentos Contempor√¢neos & Integra√ß√£o IoT

**Objetivo Expandido:** Habilitar operadores a registrar apontamentos de paradas, perdas de qualidade e trocas de turno atrav√©s de formul√°rio simples e r√°pido (<30s por registro), com valida√ß√£o em tempo real, feedback visual imediato e funcionamento 100% offline. Gateway SICFAR integra sensores KEYENCE lendo arquivos TXT (4 registros/segundo), agregando contadores em mem√≥ria por Ordem de Produ√ß√£o, e atualizando Supabase a cada 5 segundos. Operador consegue trabalhar turno completo (8h+) mesmo com internet inst√°vel.

### Story 3.1: Criar Formul√°rio de Apontamento Contempor√¢neo (UI)

**Como** operador,
**Eu quero** registrar apontamento de parada em menos de 30 segundos com formul√°rio simples,
**Para que** eu mantenha contemporaneidade (ALCOA+) sem atrasar minha produ√ß√£o.

#### Acceptance Criteria

1. Rota `/apontamento` (protegida, role: operador)
2. Layout vertical single-column (mobile-first, otimizado para telas 1366√ó768)
3. Campo "Linha" (Shadcn Select): dropdown pr√©-filtrado por setor do operador (via RLS), obrigat√≥rio
4. Campo "Turno" (auto-detectado): radio buttons desabilitados mostrando turno atual baseado em hora do sistema (6h-14h = Manh√£, 14h-22h = Tarde, 22h-6h = Noite)
5. Campo "Tipo de Evento" (radio buttons grandes): Parada, Perda de Qualidade, Troca de Turno
6. Campo "C√≥digo de Parada" (Shadcn Combobox searchable): dropdown com descri√ß√£o completa (ex: "P1.1 - Manuten√ß√£o Planejada"), filtrado por Book da linha selecionada, obrigat√≥rio
7. Campo "Quantidade Afetada" (input num√©rico): opcional para Parada, obrigat√≥rio para Perda de Qualidade
8. Campo "Observa√ß√µes" (textarea): opcional, max 500 caracteres
9. Timestamp capturado automaticamente: `new Date().toISOString()` (n√£o edit√°vel pelo usu√°rio)
10. Bot√£o prim√°rio: "Registrar Apontamento" (verde, full-width, loading state com spinner)
11. Valida√ß√µes Zod em tempo real: campos obrigat√≥rios, quantidade > 0 se Perda, linha pertence ao setor do operador
12. Formul√°rio limpa campos ap√≥s registro bem-sucedido (ready para pr√≥ximo apontamento)

---

### Story 3.2: Implementar L√≥gica de Salvamento Offline-First

**Como** operador,
**Eu quero** que apontamentos sejam salvos localmente se internet cair,
**Para que** eu n√£o perca dados contempor√¢neos durante meu turno.

#### Acceptance Criteria

1. Service `ApontamentoService.save(apontamento)` implementado
2. Detectar status de conex√£o: `navigator.onLine` ou ping em Supabase
3. Se ONLINE: tentar INSERT direto em Supabase `apontamentos` table
4. Se INSERT sucesso: retornar `{ status: 'synced', id: uuid }`
5. Se OFFLINE ou INSERT falha: salvar em IndexedDB `pending_apontamentos`
6. Retornar `{ status: 'pending_local', id: uuid_local }`
7. Toast exibido conforme status:
   - Synced: "‚úì Apontamento registrado e sincronizado"
   - Pending: "‚ö† Salvo localmente - ser√° sincronizado quando conex√£o retornar"
8. Background sync: `SyncService` tentando enviar pending_apontamentos a cada 10 segundos
9. Se sync bem-sucedido: remover de IndexedDB, atualizar badge de status no header
10. Teste manual: desconectar WiFi ‚Üí registrar apontamento ‚Üí deve salvar local ‚Üí reconectar ‚Üí deve sincronizar automaticamente

---

### Story 3.3: Adicionar Feedback Visual de Status de Sincroniza√ß√£o

**Como** operador,
**Eu quero** ver claramente se sistema est√° online e quantos apontamentos est√£o pendentes,
**Para que** eu tenha confian√ßa de que dados n√£o ser√£o perdidos.

#### Acceptance Criteria

1. Badge de status no header (sempre vis√≠vel, canto superior direito)
2. Estados do badge:
   - **Online (verde):** "üü¢ Online" - conex√£o Supabase OK
   - **Offline (amarelo):** "üü° Offline - X pendentes" - sem conex√£o, X = count de pending_apontamentos
   - **Sincronizando (azul):** "üîµ Sincronizando..." - upload em progresso
   - **Erro (vermelho):** "üî¥ Erro de conex√£o" - falha ap√≥s 3 tentativas
3. Click no badge abre modal com detalhes: lista de apontamentos pendentes, √∫ltima tentativa de sync, bot√£o "Tentar Sincronizar Agora"
4. Polling a cada 5 segundos: verificar `navigator.onLine` e count de IndexedDB
5. Anima√ß√£o no badge quando sincronizando (pulse ou spinner)
6. Toast de sucesso quando todos pendentes forem sincronizados: "‚úì Todos os apontamentos foram sincronizados"
7. Persistir estado do badge no localStorage (sobrevive a refresh da p√°gina)

---

### Story 3.4: Implementar Valida√ß√£o de C√≥digos de Parada por Book da Linha

**Como** operador,
**Eu quero** ver apenas c√≥digos de parada v√°lidos para minha linha,
**Para que** eu n√£o registre c√≥digos incorretos e cause inconsist√™ncia de dados.

#### Acceptance Criteria

1. Tabela `books_paradas` no schema: id (uuid PK), linha_id (uuid FK), codigo (text NOT NULL), classe (text), grande_parada (text), apontamento (text), grupo (text nullable), detalhamento (text nullable), is_ativo (boolean DEFAULT true)
2. Seed data: carregar Book de Paradas de SPEP (10 linhas √ó ~50 c√≥digos cada = ~500 registros)
3. Query ao selecionar linha no formul√°rio: `SELECT codigo, grande_parada, apontamento FROM books_paradas WHERE linha_id = ? AND is_ativo = true ORDER BY codigo`
4. Combobox "C√≥digo de Parada" populado com resultados (formato: "P1.1 - Manuten√ß√£o Planejada")
5. Search funcional: digitar "manut" filtra para c√≥digos contendo "manut" (case-insensitive)
6. Valida√ß√£o backend (constraint): `CHECK (codigo_parada IN (SELECT codigo FROM books_paradas WHERE linha_id = apontamentos.linha_id))`
7. Se operador tentar burlar frontend (via API direta): INSERT falha com erro "C√≥digo de parada inv√°lido para esta linha"
8. Teste: selecionar Linha A SPEP ‚Üí dropdown deve ter ~50 c√≥digos espec√≠ficos da Linha A

---

### Story 3.5: Desenvolver Gateway SICFAR (Node.js Worker)

**Como** gestor,
**Eu quero** dados de sensores KEYENCE integrados automaticamente ao sistema,
**Para que** c√°lculos de OEE reflitam produ√ß√£o real sem apontamento manual.

#### Acceptance Criteria

1. Projeto `apps/gateway` com estrutura: `src/index.ts`, `src/services/FileTailService.ts`, `src/services/SupabaseSyncService.ts`
2. FileTailService l√™ arquivo TXT via tail (biblioteca `tail` do npm): `new Tail('/path/to/keyence_output.txt')`
3. Arquivo TXT tem formato: `timestamp,linha_id,producao_count,rejeicao_count` (1 linha por registro, 4 registros/segundo)
4. Parser extrai campos: timestamp, linha_id, producao_count, rejeicao_count
5. Agregador em mem√≥ria: `Map<linha_id, { producao_acumulada, rejeicao_acumulada }>`
6. A cada novo registro: `map.get(linha_id).producao_acumulada += producao_count`
7. Timer setInterval (5 segundos): flush agregador ‚Üí UPDATE Supabase
8. Query Supabase: `UPDATE ordens_producao_ativas SET producao_acumulada = ?, rejeicao_acumulada = ?, updated_at = now() WHERE linha_id = ?`
9. Service Role Key usado para autentica√ß√£o (n√£o anon key - backend-only)
10. Retry com exponential backoff se UPDATE falhar (3 tentativas: 1s, 2s, 4s)
11. Logs estruturados: Winston logger salvando em `logs/gateway-YYYY-MM-DD.log`
12. Teste: simular arquivo TXT com 100 registros/segundo ‚Üí verificar UPDATEs a cada 5s no Supabase Dashboard

---

### Story 3.6: Configurar Gateway como Servi√ßo Windows

**Como** administrador de TI,
**Eu quero** gateway rodando como servi√ßo Windows iniciando automaticamente,
**Para que** dados de sensores continuem fluindo mesmo ap√≥s reboot do servidor.

#### Acceptance Criteria

1. Biblioteca `node-windows` instalada em `apps/gateway`
2. Script `install-service.js` criado configurando servi√ßo Windows: nome "SysOEE Gateway", descri√ß√£o, execut√°vel `node dist/index.js`
3. Service instalado via: `node install-service.js` (executar como Admin)
4. Service configurado para: Auto-start, Restart on failure (3 tentativas), Log output em `logs/service.log`
5. Comandos PowerShell funcionando: `net start "SysOEE Gateway"`, `net stop "SysOEE Gateway"`
6. Teste: reiniciar Windows Server 2019 ‚Üí gateway inicia automaticamente em 30-60s
7. Monitoramento: dashboard Supabase mostrando UPDATEs em `ordens_producao_ativas` continuando ap√≥s reboot
8. Documenta√ß√£o em README: como instalar/desinstalar/atualizar servi√ßo

---

### Story 3.7: Adicionar Tratamento de Paradas que Atravessam Meia-Noite

**Como** operador,
**Eu quero** registrar paradas que come√ßam em um dia e terminam no dia seguinte,
**Para que** dura√ß√£o seja calculada corretamente independente de atravessar meia-noite.

#### Acceptance Criteria

1. Formul√°rio de apontamento: adicionar campo "Hora In√≠cio" (time picker) e "Hora T√©rmino" (time picker)
2. Se tipo evento = "Parada": campos hora in√≠cio/t√©rmino s√£o obrigat√≥rios
3. Fun√ß√£o utilit√°ria `calculateDuration(dataOcorrencia, horaInicio, horaTermino)`:
   - Se `horaTermino > horaInicio`: dura√ß√£o = horaTermino - horaInicio
   - Se `horaTermino < horaInicio`: parada atravessou meia-noite ‚Üí dura√ß√£o = (24h - horaInicio) + horaTermino
4. Exemplo: in√≠cio 23:30, t√©rmino 00:45 ‚Üí dura√ß√£o = 0.5h + 0.75h = 1.25h (1h15min)
5. Campo `duracao_minutos` (integer) calculado e salvo em `apontamentos` table
6. Valida√ß√£o: dura√ß√£o m√°xima = 12h (se > 12h, alertar operador "Dura√ß√£o muito longa - confirme os hor√°rios")
7. Exibi√ß√£o na UI: converter minutos para formato leg√≠vel "Xh Ymin"
8. Teste: criar apontamento 23:30 ‚Üí 00:45 ‚Üí deve calcular 75 minutos corretamente

---

**Fim do Epic 3**

Este epic entrega o primeiro vertical slice completo de valor: operador registra dados contempor√¢neos + gateway captura sensores + sistema funciona offline. √â o core operacional do sistema.

---

